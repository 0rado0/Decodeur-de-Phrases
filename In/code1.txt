<html><head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>TP2 Admin SystÃ¨me - CorrigÃ©.md</title>
  <link rel="stylesheet" href="https://stackedit.io/style.css">
</head>

<body class="stackedit">
  <div class="stackedit__html"><h1 id="exercice-1---variables-denvironnement">Exercice 1 - Variables dâ€™environnement</h1>
<ol>
<li>
<p>Les commandes tapÃ©es par lâ€™utilisateur (outre les commandes internes de Bash, dont la liste peut Ãªtre consultÃ©e en tapant <code>help</code>), sont localisÃ©es dans les dossiers spÃ©cifiÃ©s par la variable dâ€™environnement <code>PATH</code>, et donc visibles en tapant <code>echo $PATH</code>.</p>
</li>
<li>
<p><code>$HOME</code></p>
</li>
<li>
<ul>
<li><code>LANG</code> : variable permettant de spÃ©cifier une <em>locale</em>, câ€™est-Ã -dire des paramÃ¨tres rÃ©gionaux</li>
<li><code>PWD</code> : dossier courant (<em>Path Working Directory</em>)</li>
<li><code>OLDPWD</code> : dossier courant prÃ©cÃ©dent (utilisÃ© quand on tape <code>cd -</code> pour nous ramener dans le dossier dans lequel nous nous trouvions prÃ©cÃ©demment)</li>
<li><code>SHELL</code> : lâ€™interprÃ©teur de commandes courant</li>
</ul>
</li>
<li>
<p><code>MY_VAR = foo</code> ; <code>echo $MY_VAR</code>.</p>
</li>
<li>
<p>Quand on saisit la commande <code>bash</code>, on ouvre un â€œsous-shellâ€ ou â€œshell filsâ€ Ã  lâ€™intÃ©rieur de celui dans lequel on se trouve. On peut ainsi imbriquer plusieurs niveaux de shell les uns Ã  lâ€™intÃ©rieur des autres. La variable dâ€™environnement <code>SHLVL</code> (<em>shell level</em>) permet de savoir dans quel niveau on se trouve.<br>
La variable <code>MY_VAR</code> Ã©tant locale, elle est inconnue dans le shell fils (les variables locales ne sont pas hÃ©ritÃ©es).<br>
La commande <code>exit</code> nous ramÃ¨ne dans le shell pÃ¨re.</p>
</li>
<li>
<p>On transforme la variable locale en variable dâ€™environnement avec la commande <code>export MY_VAR</code> ; cette fois, la variable est connue dans le shell fils : les variables dâ€™environnement sont hÃ©ritÃ©es.</p>
</li>
<li>
<p><code>export NOM="John Doe"</code> (attention, pas dâ€™espace autour du signe <code>=</code> !)</p>
</li>
<li>
<p><code>echo "Bonjour $NOM"</code></p>
</li>
<li>
<p>Une variable (dâ€™environnement ou de shell) vide continue dâ€™exister en tant que telle (par exemple les variables dâ€™environnement vides sont toujours prÃ©sentes quand on tape la commande <code>env</code>) ; la commande <code>unset</code> supprime une variable de maniÃ¨re effective.</p>
</li>
<li>
<p>Plusieurs solutions possibles :</p>
<ul>
<li><code>echo "\$HOME=$HOME"</code></li>
<li><code>echo '$HOME'=$HOME</code></li>
<li>â€¦</li>
</ul>
</li>
</ol>
<h1 id="exercice-2---contrÃ´le-de-mot-de-passe">Exercice 2 - ContrÃ´le de mot de passe</h1>
<p>ğŸ’¡ <strong>Notions abordÃ©es</strong></p>
<ul>
<li>
<p>Instruction conditionnelle <code>if</code></p>
</li>
<li>
<p>Lecture dâ€™une valeur au clavier</p>
</li>
</ul>
<pre class=" language-bash"><code class="prism  language-bash"><span class="token shebang important">#!/bin/bash</span>

PASSWORD<span class="token operator">=</span><span class="token string">"secret"</span>

<span class="token function">read</span> -s -p <span class="token string">"Saisissez votre mot de passe : "</span> input

<span class="token keyword">if</span> <span class="token punctuation">[</span> _<span class="token variable">$input</span> <span class="token operator">==</span> _<span class="token variable">$PASSWORD</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
        <span class="token keyword">echo</span> -e <span class="token string">"\nVous Ãªtes authentifiÃ© !"</span>
<span class="token keyword">else</span>
        <span class="token keyword">echo</span> -e <span class="token string">"\nErreur: mot de passe incorrect"</span>
<span class="token keyword">fi</span>
</code></pre>
<p><strong>ğŸ’¡ Auto-test</strong></p>
<ul>
<li>
<p>Pourquoi ajoute-t-on un caractÃ¨re (par exemple <code>_</code> comme ici) avant les variables dans le <code>if</code> ?</p>
</li>
<li>
<p>Quelle est lâ€™utilitÃ© de lâ€™option <code>-e</code> de <code>echo</code> ?</p>
</li>
</ul>
<h1 id="exercice-3---expressions-rationnelles">Exercice 3 - Expressions rationnelles</h1>
<p>ğŸ’¡ <strong>Notions abordÃ©es</strong></p>
<ul>
<li>Passage dâ€™argument Ã  un script</li>
<li>Fonctions Bash</li>
<li>Valeur de retour dâ€™une fonction</li>
<li>Expressions rationnelles</li>
</ul>
<pre class=" language-bash"><code class="prism  language-bash"><span class="token shebang important">#!/bin/bash</span>

<span class="token keyword">function</span> is_number<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    re<span class="token operator">=</span><span class="token string">'^[+-]?[0-9]+([.][0-9]+)?$'</span>

    <span class="token keyword">if</span> <span class="token operator">!</span> <span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token variable">$1</span> <span class="token operator">=</span>~ <span class="token variable">$re</span> <span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token punctuation">;</span> <span class="token keyword">then</span>
        <span class="token keyword">return</span> 1
    <span class="token keyword">else</span>
        <span class="token keyword">return</span> 0
    <span class="token keyword">fi</span>
<span class="token punctuation">}</span>

is_number <span class="token variable">$1</span>

<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$?</span> -eq 0 <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
    <span class="token keyword">echo</span> <span class="token string">"Le nombre est un nombre rÃ©el !"</span>
<span class="token keyword">else</span>
    <span class="token keyword">echo</span> <span class="token string">"Le nombre n'est pas un nombre rÃ©el !"</span>
<span class="token keyword">fi</span>
</code></pre>
<p>ğŸ’¡ <strong>Explications</strong></p>
<p>La fonction <code>is_number</code> renvoie 1 si le paramÃ¨tre qui lui est envoyÃ© <strong>nâ€™est pas</strong> un rÃ©el (la condition dans le <code>if</code> vÃ©rifie si le paramÃ¨tre est conforme Ã  lâ€™expression rationnelle, et on prend la nÃ©gation de cette condition avec le symbole <code>!</code>), et 0 sinon.</p>
<p>La nÃ©gation nâ€™est bien sÃ»r pas utile (on pourrait lâ€™enlever et inverser les deux <code>return</code>), elle nâ€™avait ici quâ€™un but pÃ©dagogique.</p>
<p>ğŸ’¡ <strong>Auto-test</strong></p>
<ul>
<li>
<p>Comprendre ce que reprÃ©sente et comment fonctionne lâ€™expression rationnelle <code>re</code>.</p>
</li>
<li>
<p>Comprendre la diffÃ©rence entre <code>echo</code> et <code>return</code> pour renvoyer une valeur dans une fonction.</p>
</li>
<li>
<p>A quoi correspond la variable spÃ©ciale <code>$?</code> ?</p>
</li>
</ul>
<h1 id="exercice-4---contrÃ´le-dutilisateur">Exercice 4 - ContrÃ´le dâ€™utilisateur</h1>
<p>ğŸ’¡ <strong>Notions abordÃ©es</strong></p>
<ul>
<li>
<p>Appel Ã  une commande dans un script</p>
</li>
<li>
<p>Redirections</p>
</li>
</ul>
<pre class=" language-bash"><code class="prism  language-bash"><span class="token shebang important">#!/bin/bash</span>

<span class="token keyword">if</span> <span class="token punctuation">[</span> -z <span class="token variable">$1</span> <span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">then</span>
    <span class="token keyword">echo</span> <span class="token string">"Utilisation : <span class="token variable">$0</span> nom_utilisateur"</span>
<span class="token keyword">else</span>
    <span class="token function">id</span> <span class="token variable">$1</span> <span class="token operator">&gt;</span> /dev/null 2<span class="token operator">&gt;</span><span class="token operator">&amp;</span>1

    <span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$?</span> -eq 0 <span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">then</span>
        <span class="token keyword">echo</span> <span class="token string">"L'utilisateur <span class="token variable">$1</span> existe"</span>
    <span class="token keyword">else</span>
        <span class="token keyword">echo</span> <span class="token string">"L'utilisateur <span class="token variable">$1</span> n'existe pas"</span>
    <span class="token keyword">fi</span>
<span class="token keyword">fi</span>
</code></pre>
<p>ğŸ’¡ <strong>Explications</strong></p>
<p>On commence par tester quâ€™un paramÃ¨tre a bien Ã©tÃ© fourni au script (si ce nâ€™est pas le cas, on affiche un message rappelant comment la syntaxe correcte).</p>
<p>Si on a bien un paramÃ¨tre, on lâ€™utilise pour vÃ©rifier sâ€™il correspond Ã  un utilisateur existant. Pour cela on utilise la commande <code>id</code> ; comme la plupart des commandes Linux, <code>id</code> renvoie <code>0</code> si elle se termine avec succÃ¨s (lâ€™utilisateur a Ã©tÃ© trouvÃ©) et une valeur positive en cas dâ€™Ã©chec.</p>
<p>Afin de ne pas â€œpolluerâ€ lâ€™affichage avec les messages produits par la commande <code>id</code>, on redirige ces messages vers le fichier <code>/dev/null</code>.</p>
<p>ğŸ’¡ <strong>Auto-test</strong></p>
<ul>
<li>
<p>Que se passe-t-il quand on Ã©crit dans le fichier <code>/dev/null</code> ?</p>
</li>
<li>
<p>Que signifie <code>2&gt;&amp;1</code> ?</p>
</li>
</ul>
<h1 id="exercice-5---factorielle">Exercice 5 - Factorielle</h1>
<p>ğŸ’¡ <strong>Notions abordÃ©es</strong></p>
<ul>
<li>
<p>Boucle <code>for</code></p>
</li>
<li>
<p>OpÃ©rateur de calcul arithmÃ©tique</p>
</li>
</ul>
<pre class=" language-bash"><code class="prism  language-bash"><span class="token shebang important">#!/bin/bash</span>

factorielle<span class="token operator">=</span>1

<span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token variable"><span class="token variable">`</span><span class="token function">seq</span> 1 $1<span class="token variable">`</span></span><span class="token punctuation">;</span>
<span class="token keyword">do</span>
    factorielle<span class="token operator">=</span><span class="token variable"><span class="token variable">$((</span>$factorielle <span class="token operator">*</span> $i<span class="token variable">))</span></span>
<span class="token keyword">done</span>

<span class="token keyword">echo</span> <span class="token string">"<span class="token variable">$1!</span> = <span class="token variable">$factorielle</span>"</span>
</code></pre>
<p>ğŸ’¡ <strong>Auto-test</strong></p>
<ul>
<li>Par dÃ©finition, 0! = 1. Le programme ci-dessus est-il correct ?</li>
</ul>
<h1 id="exercice-6---juste-prix">Exercice 6 - Juste prix</h1>
<p>ğŸ’¡ <strong>Notions abordÃ©es</strong></p>
<ul>
<li>
<p>Nombres alÃ©atoires</p>
</li>
<li>
<p>Boucles <code>while</code>/<code>until</code></p>
</li>
</ul>
<pre class=" language-bash"><code class="prism  language-bash"><span class="token shebang important">#!/bin/bash</span>

nb<span class="token operator">=</span><span class="token variable"><span class="token variable">$((</span> $RANDOM  <span class="token operator">%</span>  <span class="token number">1000</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token variable">))</span></span><span class="token punctuation">;</span>
essais<span class="token operator">=</span>0
input<span class="token operator">=</span>0

<span class="token keyword">while</span> <span class="token punctuation">[</span> <span class="token variable">$nb</span> -ne <span class="token variable">$input</span> <span class="token punctuation">]</span>
<span class="token keyword">do</span>
    <span class="token function">read</span> -p <span class="token string">'Tapez un nombre entre 1 et 1000 : '</span> input
    <span class="token variable"><span class="token punctuation">((</span>essais<span class="token operator">++</span><span class="token punctuation">))</span></span>

    <span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$nb</span> -gt <span class="token variable">$input</span> <span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">then</span>
        <span class="token keyword">echo</span> <span class="token string">"C'est plus grand !"</span>
    <span class="token keyword">else</span>
        <span class="token keyword">echo</span> <span class="token string">"C'est plus petit !"</span>
    <span class="token keyword">fi</span>
<span class="token keyword">done</span>

<span class="token keyword">echo</span> <span class="token string">"GagnÃ© ! Vous avez gagnÃ© en <span class="token variable">$essais</span> essais !"</span>
</code></pre>
<p>ğŸ’¡ <strong>Explications</strong></p>
<ul>
<li>
<p>Lâ€™expression <code>$RANDOM % n</code> renvoie un nombre alÃ©atoire dans lâ€™intervalle [0; n-1]. Donc on ajoute 1 pour obtenir un nombre dans lâ€™intervalle [1 ; n].</p>
</li>
<li>
<p>Le nombre dâ€™essais est incrÃ©mentÃ© Ã  chaque tentative ; câ€™est pourquoi on initialise la variable <code>essais</code> Ã  0.</p>
</li>
<li>
<p>Pour Ãªtre certain de rentrer au moins une fois dans le <code>while</code>, la condition <code>$nb -ne $input</code> ne doit pas Ãªtre vÃ©rifiÃ©e. Puisque <code>1 &lt;= nb &lt;= 1000</code>, on peut initialiser <code>input</code> Ã  0.</p>
</li>
</ul>
<p>ğŸ“ <strong>Remarque</strong></p>
<p>Il existe en Bash la boucle <code>until</code> : elle fonctionne exactement comme la boucle <code>until</code> mais sur la condition contraire. Ici, on aurait donc plus remplacer <code>while [ nb -ne input ]</code> par <code>until [ nb -eq input ]</code>.</p>
<h1 id="exercice-7---statistiques">Exercice 7 - Statistiques</h1>
<p>ğŸ’¡ <strong>Notions abordÃ©es</strong></p>
<ul>
<li>
<p>SynthÃ¨se de tout ce qui prÃ©cÃ¨de</p>
</li>
<li>
<p>DÃ©rÃ©fÃ©rencement de variable</p>
</li>
<li>
<p>Tableaux</p>
</li>
<li>
<p>Instruction <code>exit</code></p>
</li>
</ul>
<p>ğŸ“ <strong>Remarque</strong></p>
<p>Pour cet exercice en particulier, les solutions proposÃ©es sont <em>des</em> solutions parmi beaucoup dâ€™autres !</p>
<h3 id="question-1">Question 1</h3>
<p>Une premiÃ¨re version, volontairement pas la plus simple, sans le test de validitÃ© des paramÃ¨tres :</p>
<pre class=" language-bash"><code class="prism  language-bash"><span class="token shebang important">#!/bin/bash</span>

min<span class="token operator">=</span>101
max<span class="token operator">=</span>-101
somme<span class="token operator">=</span>0

<span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token variable"><span class="token variable">`</span><span class="token function">seq</span> 1 3<span class="token variable">`</span></span><span class="token punctuation">;</span> <span class="token keyword">do</span>
    <span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">${!i}</span> -lt <span class="token variable">$min</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span> min<span class="token operator">=</span><span class="token variable">${!i}</span><span class="token punctuation">;</span> <span class="token keyword">fi</span>
    <span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">${!i}</span> -gt <span class="token variable">$max</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span> max<span class="token operator">=</span><span class="token variable">${!i}</span><span class="token punctuation">;</span> <span class="token keyword">fi</span>
    somme<span class="token operator">=</span><span class="token variable"><span class="token variable">$((</span>somme <span class="token operator">+</span> ${<span class="token operator">!</span>i}<span class="token variable">))</span></span>
<span class="token keyword">done</span>

<span class="token keyword">echo</span> <span class="token string">"Le nombre minimum est <span class="token variable">$min</span>, le max est <span class="token variable">$max</span> et la moyenne est <span class="token variable"><span class="token variable">$((</span>somme <span class="token operator">/</span> <span class="token number">3</span><span class="token variable">))</span></span>"</span>
</code></pre>
<p>ğŸ’¡ <strong>Explications</strong></p>
<ul>
<li>
<p>La boucle <code>for</code> Ã©crite ici est lâ€™Ã©quivalente de la boucle <code>for(int i = 1; i &lt;= 3; i++)</code> quâ€™on aurait pu rencontrer dans dâ€™autres langages, comme C ou Java.</p>
</li>
<li>
<p>Lâ€™expression <code>$i</code> renvoie la valeur de <code>i</code> et non la valeur du <em>i-Ã¨me paramÃ¨tre</em>. Câ€™est pourquoi on doit <em>dÃ©rÃ©fÃ©rencer</em> la variable <code>i</code>.</p>
</li>
</ul>
<h4 id="test-de-validitÃ©-des-paramÃ¨tres">Test de validitÃ© des paramÃ¨tres</h4>
<p>Pour tester la validitÃ© des paramÃ¨tres, on peut commencer par Ã©crire une fonction qui teste la validitÃ© dâ€™<strong>un</strong> paramÃ¨tre. Par exemple :</p>
<pre class=" language-bash"><code class="prism  language-bash"><span class="token keyword">function</span> verifParam<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">[</span> -z <span class="token variable">$1</span> <span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token operator">!</span> <span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token variable">$1</span> <span class="token operator">=</span>~ ^-?<span class="token punctuation">[</span>0-9<span class="token punctuation">]</span>+$ <span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token punctuation">[</span> <span class="token variable">$1</span> -lt -100 <span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token punctuation">[</span> <span class="token variable">$1</span> -gt 100 <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
        <span class="token keyword">return</span> 1
    <span class="token keyword">else</span>
        <span class="token keyword">return</span> 0
    <span class="token keyword">fi</span>
<span class="token punctuation">}</span>
</code></pre>
<p>ğŸ’¡ <strong>Explications</strong></p>
<ol>
<li>
<p>Cette fonction commence par tester que le paramÃ¨tre nâ€™est pas nul</p>
</li>
<li>
<p>Ensuite elle vÃ©rifie si la valeur de ce paramÃ¨tre est un nombre entier, Ã  lâ€™aide de lâ€™expression rationnelle indiquÃ©e (câ€™est une version simplifiÃ©e de lâ€™expression de lâ€™exercice 3, qui ne tient pas compte de la partie dÃ©cimale)</p>
</li>
<li>
<p>Enfin, elle teste si cet entier ce trouve bien dans lâ€™intervalle attendu</p>
</li>
</ol>
<p>Si lâ€™un de ces tests Ã©choue, la fonction renvoie le code dâ€™erreur 1. En cas de succÃ¨s, comme dâ€™habitude, elle renvoie 0.</p>
<p>Pour tester <strong>tous</strong> les paramÃ¨tres, comme ici on nâ€™en a que trois, on pourrait Ã©ventuellement se contenter de la fonction suivante :</p>
<pre class=" language-bash"><code class="prism  language-bash"><span class="token keyword">function</span> verifTousParams<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token operator">!</span> verifParam <span class="token variable">$1</span>  <span class="token operator">||</span> <span class="token operator">!</span> verifParam <span class="token variable">$2</span>  <span class="token operator">||</span> <span class="token operator">!</span> verifParam <span class="token variable">$3</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
        <span class="token keyword">echo</span> <span class="token string">"Les 3 paramÃ¨tres doivent Ãªtre compris entre -100 et 100 !"</span>
        <span class="token keyword">exit</span> 1
    <span class="token keyword">fi</span>
<span class="token punctuation">}</span>

verifTousParams <span class="token variable">$1</span> <span class="token variable">$2</span> <span class="token variable">$3</span>
</code></pre>
<p>ğŸ’¡ <strong>Auto-test</strong></p>
<p>Il est important de bien comprendre que la notation des paramÃ¨tres :</p>
<ul>
<li>
<p>La fonction <code>verifTousParams</code> est appelÃ©e avec <strong>trois</strong> paramÃ¨tres ; Ã  lâ€™intÃ©rieur de cette fonction, les valeurs de ces paramÃ¨tres sont identifiÃ©es respectivement par <code>$1</code>, <code>$2</code> et <code>$3</code></p>
</li>
<li>
<p>Ces trois paramÃ¨tres sont donnÃ©s <strong>successivement</strong> Ã  la fonction <code>verifParam</code> qui, elle, nâ€™attend quâ€™<strong>un seul</strong> paramÃ¨tre. Donc, <strong>quel que soit le paramÃ¨tre quâ€™on lui transmet</strong>, sa valeur sera toujours identifiÃ©e par <code>$1</code> dans cette fonction.</p>
</li>
<li>
<p>Quelle est la diffÃ©rence entre <code>return 1</code> et <code>exit 1</code> ?</p>
</li>
</ul>
<h3 id="question-2">Question 2</h3>
<p>La version prÃ©cÃ©dente a un problÃ¨me majeure : elle nâ€™est pas gÃ©nÃ©rique ; le nombre de paramÃ¨tres (3), est prÃ©sent plusieurs fois en dur, et il est donc impossible dâ€™utiliser ce programme avec deux valeurs ou avec dix valeurs.</p>
<p>On peut rÃ©soudre ce problÃ¨me trÃ¨s simplement, en itÃ©rant sur la <em>liste des paramÃ¨tres</em> (ce quâ€™on aurait dâ€™ailleurs dÃ©jÃ  pu faire Ã  la question prÃ©cÃ©dente, mais la solution proposÃ©e avait lâ€™intÃ©rÃªt pÃ©dagogique dâ€™illustrer le dÃ©rÃ©fÃ©rencement). La boucle <code>for</code> devient ainsi :</p>
<pre class=" language-bash"><code class="prism  language-bash"><span class="token keyword">for</span> param <span class="token keyword">in</span> <span class="token variable">$*</span><span class="token punctuation">;</span> <span class="token keyword">do</span>
    <span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$param</span> -lt <span class="token variable">$min</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span> min<span class="token operator">=</span><span class="token variable">$param</span><span class="token punctuation">;</span> <span class="token keyword">fi</span>
    <span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$param</span> -gt <span class="token variable">$max</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span> max<span class="token operator">=</span><span class="token variable">$param</span><span class="token punctuation">;</span> <span class="token keyword">fi</span>
    somme<span class="token operator">=</span><span class="token variable"><span class="token variable">$((</span>somme <span class="token operator">+</span> $param<span class="token variable">))</span></span>
<span class="token keyword">done</span>


<span class="token keyword">echo</span> <span class="token string">"Le nombre minimum est <span class="token variable">$min</span>, le max est <span class="token variable">$max</span> et la moyenne est <span class="token variable"><span class="token variable">$((</span>somme <span class="token operator">/</span> $#<span class="token variable">))</span></span>"</span>
</code></pre>
<p>âš ï¸ Ce programme prÃ©sente dÃ©sormais un bug potentiel ! Comme on divise la somme par le nombre de paramÃ¨tre, le script peut planter si on lâ€™appelle sans paramÃ¨tre (division par 0). On corrige ce problÃ¨me en rajoutant un test avant de rentrer dans la boucle :</p>
<pre class=" language-bash"><code class="prism  language-bash"><span class="token keyword">if</span> <span class="token punctuation">[</span> $<span class="token comment"># -eq 0 ]; then</span>
   <span class="token keyword">echo</span> <span class="token string">"Utilisation: <span class="token variable">$0</span> nb1 [nb2...]"</span>
   <span class="token keyword">exit</span> 1
<span class="token keyword">fi</span>
</code></pre>
<p>Lâ€™autre problÃ¨me est quâ€™on ne peut plus utiliser la fonction <code>verifTousParams</code>, qui fonctionnait avec trois paramÃ¨tres. En rÃ©alitÃ©, on peut complÃ¨tement se passer de cette fonction : il suffit dâ€™appeler â€œnous-mÃªmesâ€ la fonction <code>verifParam</code>. Ce qui Ã©tait dâ€™abord un problÃ¨me devient ainsi un avantage, car on a un code plus concis.</p>
<pre class=" language-bash"><code class="prism  language-bash"><span class="token keyword">for</span> param <span class="token keyword">in</span> <span class="token variable">$*</span><span class="token punctuation">;</span> <span class="token keyword">do</span>
    verifParam <span class="token variable">$param</span>  <span class="token comment"># &lt;== on teste la validitÃ© du paramÃ¨tre courant</span>
    <span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$param</span> -lt <span class="token variable">$min</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span> min<span class="token operator">=</span><span class="token variable">$param</span><span class="token punctuation">;</span> <span class="token keyword">fi</span>
    <span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$param</span> -gt <span class="token variable">$max</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span> max<span class="token operator">=</span><span class="token variable">$param</span><span class="token punctuation">;</span> <span class="token keyword">fi</span>
    somme<span class="token operator">=</span><span class="token variable"><span class="token variable">$((</span>somme <span class="token operator">+</span> $param<span class="token variable">))</span></span>
<span class="token keyword">done</span>
</code></pre>
<p>ğŸ’¡ La logique entre les deux solutions est lÃ©gÃ¨rement diffÃ©rente :</p>
<ul>
<li>
<p>auparavant, on testait la validitÃ© de <strong>tous</strong> les paramÃ¨tres <strong>avant</strong> dâ€™effectuer les calculs</p>
</li>
<li>
<p>ici, on teste la validitÃ© de chaque paramÃ¨tre <strong>au fur et Ã  mesure</strong> des calculs.</p>
</li>
</ul>
<p>âš ï¸ Dans le cas prÃ©sent, cette deuxiÃ¨me solution ne pose pas de problÃ¨me car les calculs Ã  effectuer sont trÃ¨s rapides. Mais dans le cas de calculs trÃ¨s longs, il vaut mieux sâ€™assurer de la validitÃ© de tous les paramÃ¨tres avant de dÃ©marrer les calculs !!! Dans ce cas, la meilleure solution serait de conserver la fonction <code>verifTousParams</code> mais en y insÃ©rant une boucle qui teste <strong>tous</strong> les paramÃ¨tres.</p>
<p>La solution complÃ¨te :</p>
<pre class=" language-bash"><code class="prism  language-bash"><span class="token shebang important">#!/bin/bash</span>

<span class="token keyword">function</span> verifParam<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">[</span> -z <span class="token variable">$1</span> <span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token operator">!</span> <span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token variable">$1</span> <span class="token operator">=</span>~ ^-?<span class="token punctuation">[</span>0-9<span class="token punctuation">]</span>+$ <span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token punctuation">[</span> <span class="token variable">$1</span> -lt -100 <span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token punctuation">[</span> <span class="token variable">$1</span> -gt 100 <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
        <span class="token keyword">echo</span> <span class="token string">"Les paramÃ¨tres doivent Ãªtre compris entre -100 et 100 !"</span>
        <span class="token keyword">exit</span> 1
    <span class="token keyword">fi</span>
<span class="token punctuation">}</span>

<span class="token keyword">if</span> <span class="token punctuation">[</span> $<span class="token comment"># -eq 0 ]; then</span>
   <span class="token keyword">echo</span> <span class="token string">"Utilisation: <span class="token variable">$0</span> nb1 [nb2...]"</span>
   <span class="token keyword">exit</span> 1
<span class="token keyword">fi</span>

min<span class="token operator">=</span>101
max<span class="token operator">=</span>-101
somme<span class="token operator">=</span>0

<span class="token keyword">for</span> param <span class="token keyword">in</span> <span class="token variable">$*</span><span class="token punctuation">;</span> <span class="token keyword">do</span>
    verifParam <span class="token variable">$param</span>
    <span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$param</span> -lt <span class="token variable">$min</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span> min<span class="token operator">=</span><span class="token variable">$param</span><span class="token punctuation">;</span> <span class="token keyword">fi</span>
    <span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$param</span> -gt <span class="token variable">$max</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span> max<span class="token operator">=</span><span class="token variable">$param</span><span class="token punctuation">;</span> <span class="token keyword">fi</span>
    somme<span class="token operator">=</span><span class="token variable"><span class="token variable">$((</span>somme <span class="token operator">+</span> $param<span class="token variable">))</span></span>
<span class="token keyword">done</span>


<span class="token keyword">echo</span> <span class="token string">"Le nombre minimum est <span class="token variable">$min</span>, le max est <span class="token variable">$max</span> et la moyenne est <span class="token variable"><span class="token variable">$((</span>somme <span class="token operator">/</span> $#<span class="token variable">))</span></span>"</span>
</code></pre>
<h3 id="question-3">Question 3</h3>
<p>Ici, les valeurs ne sont plus donnÃ©es en paramÃ¨tres mais saisies au fur et Ã  mesure et stockÃ©es dans un tableau (bien quâ€™on puisse sâ€™en passer ici, lâ€™idÃ©e de lâ€™exercice Ã©tait dâ€™aborder les tableaux Bash).</p>
<pre class=" language-bash"><code class="prism  language-bash"><span class="token shebang important">#!/bin/bash</span>

<span class="token keyword">function</span> verifParam<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">[</span> -z <span class="token variable">$1</span> <span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token operator">!</span> <span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token variable">$1</span> <span class="token operator">=</span>~ ^-?<span class="token punctuation">[</span>0-9<span class="token punctuation">]</span>+$ <span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token punctuation">[</span> <span class="token variable">$1</span> -lt -100 <span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token punctuation">[</span> <span class="token variable">$1</span> -gt 100 <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
        <span class="token keyword">echo</span> <span class="token string">"Les paramÃ¨tres doivent Ãªtre compris entre -100 et 100 !"</span>
        <span class="token keyword">return</span> 1
    <span class="token keyword">fi</span>
<span class="token punctuation">}</span>

val<span class="token operator">=</span>0
tab<span class="token operator">=</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">while</span> <span class="token punctuation">[</span> <span class="token variable">$val</span> <span class="token operator">!=</span> <span class="token string">'q'</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">do</span>
    <span class="token function">read</span> -p <span class="token string">"Saisissez un nombre entre -100 et 100, ou 'q' pour arrÃªter la saisie : "</span> val

    <span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$val</span> <span class="token operator">!=</span> <span class="token string">'q'</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
        verifParam <span class="token variable">$val</span>
        <span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$?</span> -eq 0 <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
            tab<span class="token punctuation">[</span><span class="token variable">${#tab[@]}</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token variable">$val</span>
        <span class="token keyword">fi</span>
    <span class="token keyword">fi</span>
<span class="token keyword">done</span><span class="token punctuation">;</span>

min<span class="token operator">=</span>101
max<span class="token operator">=</span>-101
somme<span class="token operator">=</span>0

<span class="token keyword">for</span> val <span class="token keyword">in</span> <span class="token variable">${tab[*]}</span>
<span class="token keyword">do</span>
    <span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$val</span> -lt <span class="token variable">$min</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span> min<span class="token operator">=</span><span class="token variable">$val</span><span class="token punctuation">;</span> <span class="token keyword">fi</span>
    <span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$val</span> -gt <span class="token variable">$max</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span> max<span class="token operator">=</span><span class="token variable">$val</span><span class="token punctuation">;</span> <span class="token keyword">fi</span>
    somme<span class="token operator">=</span><span class="token variable"><span class="token variable">$((</span>somme <span class="token operator">+</span> $val<span class="token variable">))</span></span>
<span class="token keyword">done</span>

<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">${#tab[@]}</span> -gt 0 <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
    <span class="token keyword">echo</span> <span class="token string">"Valeurs saisies : <span class="token variable">${tab[*]}</span>"</span>
    <span class="token keyword">echo</span> <span class="token string">"Le nombre minimum est <span class="token variable">$min</span>, le max est <span class="token variable">$max</span> et la moyenne est <span class="token variable"><span class="token variable">$((</span>somme <span class="token operator">/</span> ${#tab[@]}<span class="token variable">))</span></span>"</span>
<span class="token keyword">fi</span>
</code></pre>
<p>ğŸ’¡ <strong>Explications</strong></p>
<p>jâ€™ai lÃ©gÃ¨rement changÃ© la logique du programme :</p>
<ul>
<li>
<p>les valeurs sont dâ€™abord toutes stockÃ©es dans le tableau avant de lancer les calculs</p>
</li>
<li>
<p>le programme ne sâ€™arrÃªte plus quand on saisie une mauvaise valeur, elle nâ€™est juste pas stockÃ©e dans le tableau (dâ€™oÃ¹ le remplacement de <code>exit 1</code> par <code>return 1</code> dans la fonction).</p>
</li>
</ul>
<h1 id="exercice-8">Exercice 8</h1>
<pre class=" language-bash"><code class="prism  language-bash"><span class="token shebang important">#!/bin/bash</span>

<span class="token keyword">echo</span> -n <span class="token string">"FG \ BG   "</span>

<span class="token comment"># Couleur du texte</span>
<span class="token keyword">for</span> clfg <span class="token keyword">in</span> <span class="token punctuation">{</span>0<span class="token punctuation">..</span>7<span class="token punctuation">}</span> <span class="token punctuation">{</span>30<span class="token punctuation">..</span>37<span class="token punctuation">}</span> <span class="token punctuation">;</span> <span class="token keyword">do</span>
<span class="token comment">#for clfg in 0 1 4 5 7 {30..37} ; do</span>
    <span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$clfg</span> -ne 0 <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span> <span class="token keyword">echo</span> -en <span class="token string">"<span class="token variable">$clfg</span>\t"</span><span class="token punctuation">;</span> <span class="token keyword">fi</span>
    <span class="token comment"># Couleur de fond</span>
    <span class="token keyword">for</span> clbg <span class="token keyword">in</span> <span class="token punctuation">{</span>40<span class="token punctuation">..</span>47<span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token keyword">do</span>
        <span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$clfg</span> -eq 0 <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
            <span class="token keyword">echo</span> -n <span class="token string">"<span class="token variable">$clbg</span>    "</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span>
            <span class="token keyword">echo</span> -en <span class="token string">"\e[<span class="token variable">${clbg}</span>;<span class="token variable">${clfg}</span>m Bash \e[0m"</span>
        <span class="token keyword">fi</span>
    <span class="token keyword">done</span>
    <span class="token keyword">echo</span> <span class="token comment">#Newline</span>
<span class="token keyword">done</span>
</code></pre>
</div>



</body></html>